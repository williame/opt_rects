<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>http://stackoverflow.com/questions/14315104/optimising-the-drawing-of-overlapping-rectangles</title>
<style type="text/css">
html, body { border:0px;margin:0px;padding:0px; color:white; background-color:black;}
#game-canvas { width:100%; border:0px;margin:0px;padding:0px; }
</style>
<script type="text/javascript" src="collisions.js"></script>
<script type="text/javascript" src="glutil.js"></script>
<script type="text/javascript" src="ui.js"></script>
<script type="text/javascript">

var gl, canvas, octree, ctx, colours;

function sortByZ(a,b) { return a.z-b.z; }

function sortByColour(a,b) { return a.colour-b.colour; }

var sortFunc = sortByZ; //### can be changed to sortByColour with C key

// call this function to draw all the sprites to the appropriate context
function draw(visibleRect,octree,ctx) {
	var t = now();
	// get the sprites that are visible
	var sprites = [];
	octree.find(visibleRect,sprites);
	sprites.sort(sortFunc);
	// and draw them
	ctx.clear();
	for(var sprite in sprites) {
		sprite = sprites[sprite];
		var	rect = sprite.rect,
			colour = colours[sprite.colour],
			corner = sprite.corner;
		ctx.fillRoundedRect(colour.rgba,corner,rect[0],rect[1],rect[2],rect[3]);
	}
	ctx.finish();
	console.log(""+sortFunc,sprites.length,ctx.buffers.length,t-lastDraw);
	lastDraw = t;
}

function start() {
	// create the opengl context
	canvas = document.getElementById("game-canvas");
	try {
		gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
	} catch(e) {
		console.log("Error initializing webGL:",e);
	}
	if(!gl) {
		console.log(gl);
		alert("Unable to initialize WebGL. Your browser may not support it.");
		return;
	}
	glInit();
  	window.onresize = function() {
  		canvas.style.height = (window.innerHeight - canvas.offsetTop)+"px";
		canvas.width = canvas.offsetWidth;
		canvas.height = canvas.offsetHeight;
		gl.viewport(0,0,canvas.offsetWidth,canvas.offsetHeight);
		visibleRect = null;
	};
	window.onresize();

	// create the test data
	colours = [];
	for(var i=0; i<5; i++) // from a palette of 10 colours
		colours.push({
			rgba: [Math.random(),Math.random(),Math.random(),Math.max(0.3,Math.random())],
			tex:  createTexture(1,1,new Uint8Array([255,255,255,255])),
		});
	var sprites = [];
	for(var i=0; i<10000; i++) { // we have 10K rectangles
		var	x = Math.random()*10000,
			y = Math.random()*10000,
			w = Math.random()*300+10,
			h = Math.random()*300+10,
			colour = Math.floor(Math.random()*colours.length),
			corner = Math.min(20,Math.max(1,Math.floor(Math.min(w,h)/2)));
		sprites.push({
			rect: [x,y,x+w,y+h],
			colour: colour,
			z: i,
			corner: corner,
		});
	}
	
	// for this example, we'll put the sprites into a crude, static octree
	octree = make_tree(sprites,function(sprite) {
		var rect = sprite.rect, corner = sprite.corner;
		return [rect[0]-corner,rect[1]-corner,rect[2]+corner,rect[3]+corner];
	});
	
	document.addEventListener("keyup",function(evt) {
		if(evt.which == 67 || evt.which == 99) // C
			sortFunc = sortByColour;
		else if(evt.which == 90 || evt.which == 122) // Z
			sortFunc = sortByZ;
	},true);

	// ready to go
	ctx = new UIContext();
	requestAnimFrame(loop);
}

function assert(condition,msg) {
	if(!condition) throw new Error(msg||"an error occurred");
}

function now() { return (new Date()).getTime(); }

var	winOfs = [500,500],
	visibleRect,
	move = vec2_normalise([Math.max(0.2,Math.random()),Math.max(0.2,Math.random())]),  // 1 pixel per redraw loop
	lastDraw = now();

function loop() {
	window.requestAnimFrame(loop);
	// move the camera around, bouncing off edges
	if(winOfs[0] + move[0] < 0 || winOfs[0] + move[0] > canvas.width)
		move[0] = -move[0];
	winOfs[0] += move[0];
	if(winOfs[1] + move[1] < 0 || winOfs[1] + move[1] > canvas.height)
		move[1] = -move[1];
	winOfs[1] += move[1];
	// has visibility changed? work out what to draw
	var screenRect = [winOfs[0],winOfs[1],winOfs[0]+canvas.width,winOfs[1]+canvas.height];
	if(!visibleRect || !aabb_contains(visibleRect,screenRect)) {
		var FRINGE = 10; // if we add a border to our visibleRect, we don't have to update it every n frames
		visibleRect = [screenRect[0]-FRINGE,screenRect[1]-FRINGE,screenRect[2]-FRINGE,screenRect[3]-FRINGE];
		draw(visibleRect,octree,ctx);
	}
	ctx.draw(createOrtho2D(screenRect[0],screenRect[2],screenRect[1],screenRect[3],-100,800));
}

window.requestAnimFrame = 
	window.requestAnimationFrame ||
	window.webkitRequestAnimationFrame ||
	window.mozRequestAnimationFrame ||
	window.oRequestAnimationFrame ||
	window.msRequestAnimationFrame ||
	function(callback) {
		window.setTimeout(callback,1000/60);
	};

</script>
<body onload="start();">
<h1>This is a simple test app to find a sane to draw a complex scene</h1>
<div>Please see <a href="http://stackoverflow.com/questions/14315104/optimising-the-drawing-of-overlapping-rectangles">
http://stackoverflow.com/questions/14315104/optimising-the-drawing-of-overlapping-rectangles</a> for the question with a <b>+500</b> bounty!<br/>
(use <b>C</b> to sort-by-colour and <b>Z</b> to sort-by-Z)</div>
<noscript>
Sorry, you don't have Javascript enabled :(<br/>
</noscript>
<canvas id="game-canvas">
Sorry, you don't have webGL enabled :(
</canvas>
</body>
</html>
